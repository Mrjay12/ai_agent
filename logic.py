# logic.py

import os
import time
from pathlib import Path
from typing import List, Dict, Any

class SelfImprovingLogic:
    """
    Core logic engine that enables JARVIS to reflect on and improve its own code.
    This class does NOT contain hardcoded rules or traits.
    All insights are generated by the LLM and stored as free-form reflections.
    """

    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root).resolve()
        self.reflections_path = self.project_root / "jarvis_reflections.log"
        self._ensure_log()

    def _ensure_log(self):
        """Create reflections log if missing."""
        if not self.reflections_path.exists():
            with open(self.reflections_path, "w", encoding="utf-8") as f:
                f.write(f"# JARVIS Self-Reflection Log\n# Started: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")

    def log_reflection(self, reflection: str):
        """Append a free-form reflection generated by the LLM."""
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
        entry = f"[{timestamp}] SELF-REFLECTION:\n{reflection}\n{'-'*60}\n"
        with open(self.reflections_path, "a", encoding="utf-8") as f:
            f.write(entry)

    def get_recent_reflections(self, limit: int = 3) -> str:
        """Return last N reflections for context injection."""
        if not self.reflections_path.exists():
            return ""
        with open(self.reflections_path, "r", encoding="utf-8") as f:
            lines = f.readlines()
        # Extract full reflection blocks
        blocks = []
        current = []
        for line in lines:
            if line.startswith("[") and "] SELF-REFLECTION:" in line:
                if current:
                    blocks.append("".join(current))
                current = [line]
            else:
                current.append(line)
        if current:
            blocks.append("".join(current))
        recent = blocks[-limit:] if blocks else []
        return "\n".join(recent)

    def read_source(self, filepath: str) -> str:
        """Read any .py file in the project."""
        full_path = (self.project_root / filepath).resolve()
        if not str(full_path).startswith(str(self.project_root)):
            return "[ERROR] Access denied: outside project root."
        if full_path.suffix != ".py":
            return "[ERROR] Only .py files allowed."
        try:
            return full_path.read_text(encoding="utf-8")
        except Exception as e:
            return f"[ERROR] {str(e)}"

    def propose_improved_code(self, filepath: str, current_code: str, feedback: str = "") -> str:
        """
        This method is NOT called directly.
        It defines the prompt that the LLM will use when the 'propose_code_improvement' tool is invoked.
        """
        return (
            "You are JARVIS. You are reviewing your own source code to improve it.\n"
            f"File: {filepath}\n"
            f"User feedback: {feedback or 'None'}\n"
            "Current code:\n```python\n" + current_code + "\n```\n"
            "Generate an improved version of the entire file. "
            "Fix bugs, improve clarity, add missing features, or enhance self-improvement capability. "
            "Return ONLY the improved Python code — no explanations."
        )

    def save_proposed_code(self, filepath: str, new_code: str) -> str:
        """Save improved code as .new — never overwrite original."""
        full_path = (self.project_root / filepath).resolve()
        new_path = full_path.with_suffix(".py.new")
        try:
            new_path.write_text(new_code, encoding="utf-8")
            return f"[SUCCESS] Proposed improvement saved to: {new_path}"
        except Exception as e:
            return f"[ERROR] Failed to save: {str(e)}"